{"version":3,"file":"static/js/506.2b5be8b9.chunk.js","mappings":"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","sources":["utils/data.ts"],"sourcesContent":["/**\r\n * Fetch in-app Data Util\r\n */\r\n\r\n// Dependencies\r\nimport allTags from '../data/tags.json';\r\nimport allResources from '../data/resources.json';\r\nimport allNotifications from '../data/notifications.json';\r\nimport allRoadMaps from '../data/roadmaps.json';\r\n\r\n// Get Read Notifications from Local Storage, parse it if it's there\r\n// If not there, then return an empty array.\r\nconst readNotifications: string[] = localStorage.getItem('readNotifications')\r\n\t? JSON.parse(localStorage.getItem('readNotifications') || '{}')\r\n\t: [];\r\n\r\ninterface ResourcesUtility {\r\n\tgetResources: (\r\n\t\tpage?: number,\r\n\t\tlimit?: number,\r\n\t\ttags?: Tags,\r\n\t\tsearch?: string\r\n\t) => Promise<Resource[]>;\r\n\tgetSingleResource: (name: string) => Promise<Resource> | any;\r\n\tgetTotalPages: () => Promise<number>;\r\n\tgetTotalResources: () => Promise<number>;\r\n}\r\n\r\ninterface TagUtility {\r\n\tgetTags: () => Promise<Tags>;\r\n}\r\n\r\ninterface NotificationUtility {\r\n\tgetAllNotification: () => Promise<Notification[]>;\r\n\tupdateReadNotifications: (\r\n\t\tnotificationId: string\r\n\t) => Promise<string | Error | undefined>;\r\n}\r\n\r\ninterface RoadmapsUtility {\r\n\tgetRoadmaps: () => Promise<IRoadmap[]>;\r\n\tgetSingleRoadmap: (id: string) => Promise<IRoadmap | undefined>;\r\n\tgetResourcesOfRoadmap: (id: string) => Promise<Resource[]> | any;\r\n\tgetTotalRoadmaps: () => Promise<number>;\r\n}\r\n\r\n/**\r\n * Data Utility Class\r\n */\r\nclass Data {\r\n\tstatic get Resources() {\r\n\t\tconst resourceUtility = {} as ResourcesUtility;\r\n\r\n\t\t/**\r\n\t\t * @description Get all resources in paginated manner\r\n\t\t * @param {number} page The current page\r\n\t\t * @param {number} limit The amount of items to display per page\r\n\t\t * @param {string[]} tags search for tags\r\n\t\t * @param {string} search search for resource by name, description or url\r\n\t\t * @returns {Resource[]} Array of resources\r\n\t\t */\r\n\t\tresourceUtility.getResources = async (\r\n\t\t\tpage = 1,\r\n\t\t\tlimit = 20,\r\n\t\t\ttags = [],\r\n\t\t\tsearch?: string\r\n\t\t) => {\r\n\t\t\tlet resources: Resource[] = allResources;\r\n\t\t\tif (search) {\r\n\t\t\t\tresources = resources.filter((resource) => {\r\n\t\t\t\t\tsearch = search!.replace(/([^a-zA-z0-9]+)/g, '');\r\n\t\t\t\t\tconst searchRegExp = new RegExp(search, 'ig');\r\n\t\t\t\t\tconst tags = resource.tags.join(' ');\r\n\t\t\t\t\treturn (\r\n\t\t\t\t\t\tsearchRegExp.test(resource.name) ||\r\n\t\t\t\t\t\tsearchRegExp.test(resource.description) ||\r\n\t\t\t\t\t\tsearchRegExp.test(resource.url) ||\r\n\t\t\t\t\t\ttags.match(searchRegExp)\r\n\t\t\t\t\t);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\tif (tags?.length > 0) {\r\n\t\t\t\tresources = resources.filter((resource) => {\r\n\t\t\t\t\treturn resource.tags.find((tag) => tags.includes(tag));\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\treturn resources.slice((page - 1) * limit, page * limit);\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * @description Get's a single resources by it's name\r\n\t\t * @param {string} name name of the page looking for\r\n\t\t * @returns {Resource} Matching Resource\r\n\t\t */\r\n\t\tresourceUtility.getSingleResource = async (name: string) => {\r\n\t\t\treturn allResources.find((resource) => {\r\n\t\t\t\tconst url = new URL(resource.url).hostname.split('.').shift();\r\n\t\t\t\treturn url === name;\r\n\t\t\t});\r\n\t\t};\r\n\r\n\t\tresourceUtility.getTotalPages = async () => {\r\n\t\t\treturn Math.ceil(allResources.length / 20);\r\n\t\t};\r\n\r\n\t\tresourceUtility.getTotalResources = async () => {\r\n\t\t\treturn allResources.length;\r\n\t\t};\r\n\r\n\t\treturn resourceUtility;\r\n\t}\r\n\r\n\tstatic get Tags() {\r\n\t\tconst tagUtility = {} as TagUtility;\r\n\r\n\t\t/**\r\n\t\t * @description Get all tags\r\n\t\t * @returns {Tags} Tags\r\n\t\t */\r\n\t\ttagUtility.getTags = async () => {\r\n\t\t\treturn allTags;\r\n\t\t};\r\n\r\n\t\treturn tagUtility;\r\n\t}\r\n\r\n\tstatic get Notifications() {\r\n\t\tconst notificationUtility = {} as NotificationUtility;\r\n\r\n\t\t/**\r\n\t\t * @description Compares read notifications and new notifications,\r\n\t\t * returns true if already read and false if not for *read* property.\r\n\t\t * @returns {array} Array of All notifications\r\n\t\t */\r\n\t\tnotificationUtility.getAllNotification = async () => {\r\n\t\t\ttry {\r\n\t\t\t\tallNotifications.forEach((notification: Notification | any) => {\r\n\t\t\t\t\tnotification.read = false;\r\n\t\t\t\t\tif (\r\n\t\t\t\t\t\treadNotifications.find(\r\n\t\t\t\t\t\t\t(readNotification) =>\r\n\t\t\t\t\t\t\t\treadNotification === notification.id\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t) {\r\n\t\t\t\t\t\tnotification.read = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t\treturn allNotifications as Notification[];\r\n\t\t\t} catch (error) {\r\n\t\t\t\treturn Promise.reject(error);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * @description Update notification as read using notification Id\r\n\t\t * @param {string} notificationId notification Id to be added to read notifications\r\n\t\t * @returns {string} 'Notification marked as read!'\r\n\t\t */\r\n\t\tnotificationUtility.updateReadNotifications = async (\r\n\t\t\tnotificationId: string\r\n\t\t) => {\r\n\t\t\ttry {\r\n\t\t\t\tconst readNotification: any = allNotifications.find(\r\n\t\t\t\t\t(notification: any) => notification.id === notificationId\r\n\t\t\t\t);\r\n\t\t\t\tif (!readNotification)\r\n\t\t\t\t\tthrow new Error(\r\n\t\t\t\t\t\t'Notification with give Id does not exist!'\r\n\t\t\t\t\t);\r\n\t\t\t\tif (readNotifications.find((noti) => noti === notificationId))\r\n\t\t\t\t\treturn;\r\n\t\t\t\treadNotifications.push(readNotification.id);\r\n\t\t\t\tlocalStorage.setItem(\r\n\t\t\t\t\t'readNotifications',\r\n\t\t\t\t\tJSON.stringify(readNotifications)\r\n\t\t\t\t);\r\n\t\t\t\treturn 'Notification marked as read!';\r\n\t\t\t} catch (error) {\r\n\t\t\t\treturn Promise.reject(error);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\treturn notificationUtility;\r\n\t}\r\n\r\n\tstatic get Roadmaps() {\r\n\t\tconst roadmapsUtility = {} as RoadmapsUtility;\r\n\r\n\t\troadmapsUtility.getRoadmaps = async () => {\r\n\t\t\treturn allRoadMaps;\r\n\t\t};\r\n\r\n\t\troadmapsUtility.getSingleRoadmap = async (id: string) => {\r\n\t\t\treturn allRoadMaps.find((roadmap) => roadmap.id === id);\r\n\t\t};\r\n\r\n\t\troadmapsUtility.getResourcesOfRoadmap = async (id: string) => {\r\n\t\t\treturn allResources.filter((resource) =>\r\n\t\t\t\tresource.roadmap ? resource.roadmap.ids.includes(id) : false\r\n\t\t\t);\r\n\t\t};\r\n\r\n\t\troadmapsUtility.getTotalRoadmaps = async () => {\r\n\t\t\treturn allRoadMaps.length;\r\n\t\t};\r\n\r\n\t\treturn roadmapsUtility;\r\n\t}\r\n}\r\n\r\nexport default Data;\r\n"],"names":["readNotifications","localStorage","getItem","JSON","parse","Data","resourceUtility","getResources","page","limit","tags","search","resources","allResources","filter","resource","replace","searchRegExp","RegExp","join","test","name","description","url","match","length","find","tag","includes","slice","getSingleResource","URL","hostname","split","shift","getTotalPages","Math","ceil","getTotalResources","tagUtility","getTags","allTags","notificationUtility","getAllNotification","allNotifications","notification","read","readNotification","id","Promise","reject","updateReadNotifications","notificationId","Error","noti","push","setItem","stringify","roadmapsUtility","getRoadmaps","allRoadMaps","getSingleRoadmap","roadmap","getResourcesOfRoadmap","ids","getTotalRoadmaps"],"sourceRoot":""}